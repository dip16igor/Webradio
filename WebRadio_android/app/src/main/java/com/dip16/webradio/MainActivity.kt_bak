package com.dip16.webradio

import android.annotation.SuppressLint
import android.content.Context
import android.media.MediaPlayer
import android.os.Build
import android.os.Bundle
import android.util.Log
import android.view.View
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import com.dip16.webradio.ui.theme.WebRadioTheme
//import androidx.compose.material.Button
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import org.eclipse.paho.client.mqttv3.MqttClient
import org.eclipse.paho.client.mqttv3.MqttMessage
import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material.icons.filled.Done
import androidx.compose.material.icons.filled.KeyboardArrowDown
import androidx.compose.material.icons.filled.KeyboardArrowUp
import androidx.compose.material.icons.filled.Notifications
import androidx.compose.material3.Divider
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.TextField
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableIntStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalView
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.DpOffset
import androidx.core.content.ContextCompat
import androidx.core.view.ViewCompat
import androidx.core.view.WindowCompat
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken
import org.eclipse.paho.client.mqttv3.MqttCallbackExtended
import org.eclipse.paho.client.mqttv3.MqttConnectOptions
import org.eclipse.paho.client.mqttv3.MqttException

private const val mqttBrokerUrl: String = "tcp://v.66p.su:1883"
const val radioName = "WebRadio2" // 1 - Челябинск. 2 - Куса
private val alarms = listOf("5:00", "5:30", "6:00", "6:30", "7:00", "Alarm OFF")

class MainActivity : ComponentActivity() {

    private lateinit var client: MqttClient

    private val station = mutableStateOf("")
    private val title = mutableStateOf("")
    private val state = mutableStateOf("")
    private val volume = mutableStateOf("")
    private val logText = mutableStateOf("")
    private val connectionState = mutableStateOf("")
    private val selectedIndex = mutableStateOf<Int?>(null) // Инициализация с null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Log.i("dip17", "onCreate(savedInstanceState)")
        setContent {
            WebRadioTheme {
                Log.i("dip17", "WebRadioTheme")
                // A surface container using the 'background' color from the theme
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    MQTTButtonsScreen(buttonDataList)
                }
            }
        }
    }

    override fun onStart() {
        super.onStart()
        Log.d("dip17", "onStart()")
        CoroutineScope(Dispatchers.IO).launch {
            // Подключение к MQTT и подписка на топик
            ConnectToMQTT()
        }
    }

    override fun onResume() {
        super.onResume()
        Log.d("dip17", "onResume()")
//        if (client.isConnected) {
//            val msg = MqttMessage("?".toByteArray())
//           // client.publish("Home/$radioName/Action", msg)
//           // Log.d("dip17", "request '?' sent")
//        }

    }

    override fun onStop() {
        super.onStop()
        Log.d("dip17", "onStop()")
        // Отключение от MQTT
        disconnectFromMQTT()
    }

    @SuppressLint("DefaultLocale")
    fun convertSecondsToTime(seconds: Int): String {
        val hours = seconds / 3600
        val minutes = (seconds % 3600) / 60
        return "$hours:${String.format("%02d", minutes)}"
    }

    //@Composable
    private fun ConnectToMQTT() {
        val persistence = MemoryPersistence()
        //val context = LocalContext.current
        val mqttClientId = MqttClient.generateClientId()
        client = MqttClient(mqttBrokerUrl, mqttClientId, persistence)
        Log.d("dip17", "try to connect to MQTT broker")
        Log.d("dip17", "my ID is $mqttClientId")
        station.value = " - - - "
        title.value = " - - - "
        state.value = " - - - "
        volume.value = "--"
        logText.value = " "
        selectedIndex.value = null

        try {
            val options = MqttConnectOptions().apply {
                isCleanSession = true
                isAutomaticReconnect = true // включаем автоматическое переподключение
                maxReconnectDelay = 2000
            }
            client.setCallback(object : MqttCallbackExtended {
                override fun connectComplete(reconnect: Boolean, serverURI: String) {
                    //connectionState.value = "OK"
                    connectionState.value = "Connection OK"
                    Log.d("dip17", "connectComplete to $mqttBrokerUrl")
                    if (reconnect) {
                        Log.d("dip17", "reconnect. Subscribe")
                        //                    client.connect(options)
                        client.subscribe("Home/$radioName/State") { _, msg ->
                            connectionState.value = " "
                            val newState = msg.toString()
                            state.value = newState.ifEmpty { " " }
                            Log.d("dip17", "State -> $newState")
                            //title.value = msg.toString()
                        }
                        client.subscribe("Home/$radioName/Log") { _, msg ->
                            connectionState.value = " "
                            val newLog = msg.toString()
                            logText.value = newLog.ifEmpty { " " }
                            Log.d("dip17", "State -> $newLog")
                        }
                        client.subscribe("Home/$radioName/Station") { _, msg ->
                            connectionState.value = " "
                            station.value = msg.toString()
                            Log.d("dip17", "Station -> ${station.value}")
//                            CoroutineScope(Dispatchers.IO).launch {
//                                val mediaPlayer = MediaPlayer.create(context, R.raw.button1)
//                                mediaPlayer.start()
//                            }
                        }
                        client.subscribe("Home/$radioName/Title") { _, msg ->
                            connectionState.value = " "
                            val newTitle = msg.toString()
                            title.value = newTitle.ifEmpty { " " }
                            Log.d("dip17", "Title -> $newTitle")
                            //title.value = msg.toString()
                        }
                        client.subscribe("Home/$radioName/Volume") { _, msg ->
                            connectionState.value = " "
                            val newVolume = msg.toString()
                            volume.value = newVolume.ifEmpty { " " }
                            Log.d("dip17", "Volume -> $newVolume")
                            //title.value = msg.toString()
                        }
                        client.subscribe("Home/$radioName/Alarm") { _, msg ->
                            connectionState.value = " "
                            val newAlarm = msg.toString()
                            Log.d("dip17", "Alarm -> $newAlarm")
                            if (newAlarm != "Alarm OFF") {
                                val ssInt = newAlarm.toInt()
                                val tt = convertSecondsToTime(ssInt)
                                Log.d("dip17", tt)
                            } else {
                                // selectedIndex = 0
                                Log.d("dip17", "Alarm OFF!")
                            }
                        }
                    }
                }

                override fun connectionLost(cause: Throwable?) {
                    connectionState.value = "Connection LOST.."
                    Log.e("dip17", "Connection lost to $mqttBrokerUrl  $cause")
                }

                override fun messageArrived(topic: String?, message: MqttMessage?) {
                    // Обработка полученных сообщений
                    Log.d("dip17", "Message received from $topic $message")
                }

                override fun deliveryComplete(token: IMqttDeliveryToken?) {
                    // Обработка доставки сообщений
                    Log.d("dip17", "deliveryComplete. Token : $token")
                }
            })

            connectionState.value = "Try to connect.."

            client.connect(options)


        } catch (e: MqttException) {
            Log.e("dip17", "Fail connect to $mqttBrokerUrl !\n $e")
            e.printStackTrace()

            connectionState.value = "Connection Failed!"

        }
        if (client.isConnected) {
            //logText.value += "Send request" + "\n"
            Log.d("dip17", "connected!")

            connectionState.value = "Subscribe"

            client.subscribe("Home/$radioName/State") { _, msg ->
                connectionState.value = " "
                val newState = msg.toString()
                state.value = newState.ifEmpty { " " }
                Log.d("dip17", "State -> $newState")
                //title.value = msg.toString()
            }
            client.subscribe("Home/$radioName/Log") { _, msg ->
                connectionState.value = " "
                val newLog = msg.toString()
                logText.value = newLog.ifEmpty { " " }
                Log.d("dip17", "State -> $newLog")
            }
            client.subscribe("Home/$radioName/Station") { _, msg ->
                connectionState.value = " "
                station.value = msg.toString()
                Log.d("dip17", "Station -> ${station.value}")
                CoroutineScope(Dispatchers.IO).launch {
                    //val mediaPlayer = MediaPlayer.create(context, R.raw.button1)
                    //mediaPlayer.start()
                }
            }
            client.subscribe("Home/$radioName/Title") { _, msg ->
                connectionState.value = " "
                val newTitle = msg.toString()
                title.value = newTitle.ifEmpty { " " }
                Log.d("dip17", "Title -> $newTitle")
                //title.value = msg.toString()
            }

            client.subscribe("Home/$radioName/Volume") { _, msg ->
                connectionState.value = " "
                val newVolume = msg.toString()
                volume.value = newVolume.ifEmpty { " " }
                Log.d("dip17", "Volume -> $newVolume")
                //title.value = msg.toString()
            }

            client.subscribe("Home/$radioName/Alarm") { _, msg ->
                connectionState.value = " "
                val newAlarm = msg.toString()
                Log.d("dip17", "Alarm -> $newAlarm")
                if (newAlarm != "Alarm OFF") {
                    val ssInt = newAlarm.toInt()
                    val tt = convertSecondsToTime(ssInt)
                    Log.d("dip17", tt)

                    val idx = alarms.indexOf(tt)
                    if (idx != -1) {
                        selectedIndex.value = idx
                        Log.d("dip17", "Номер пункта меню: $idx")
                    } else {
                        Log.d("dip17", "какая-то ошибка")
                    }

                } else {
                    selectedIndex.value = alarms.lastIndex
                    Log.d("dip17", "Alarm OFF!")
                }
            }


            connectionState.value = "Send request"
            //sendMessage("?")
            val msg = MqttMessage("?".toByteArray())
            client.publish("Home/$radioName/Action", msg)
            Log.d("dip17", "request '?' sent")

//            LaunchedEffect(Unit) {
//                while (true) {
//                    delay(2000) // задержка в 1 секунду
//                    Log.d("dip17", "2000 ms !")
//                    // выполнение вашего события
//                }
//            }

        } else {
            //logText.value += "Client not connected!" + "\n"
            Log.e("dip17", "Client not connected!")
            connectionState.value = "Client not connected!"
        }
    }

    private fun disconnectFromMQTT() {
        try {
            client.disconnect()
        } catch (e: MqttException) {
            e.printStackTrace()
        }
        Log.d("dip17", "disconnected!")
    }

    data class ButtonData(val buttonText: String, val genre: String, val messageText: String)

    @Composable
    fun MQTTButtonsScreen(
        buttonDataList: List<ButtonData>,
    ) {
        val displayMetrics = LocalContext.current.resources.displayMetrics
        val screenWidth = displayMetrics.xdpi
        val coroutineScope = rememberCoroutineScope()
        var expanded by remember { mutableStateOf(false) }

        val context = LocalContext.current
        val view = LocalView.current

        // Определите, сколько кнопок вы хотите видеть в строке
        val cellsCount = 2

        // Определяем цвет иконки в зависимости от selectedIndex
        val iconColor = when {
            //selectedIndex.value == null -> Color.Red // Цвет по умолчанию, если selectedIndex == null
            selectedIndex.value == null -> MaterialTheme.colorScheme.background // Цвет по умолчанию, если selectedIndex == null
            selectedIndex.value != alarms.lastIndex -> MaterialTheme.colorScheme.primary // Цвет для selectedIndex != lastIndex
            else -> Color.Gray // Цвет по умолчанию
        }

//        val activity = context as? ComponentActivity
//        // цвет статус бара
//        activity?.window?.statusBarColor = ContextCompat.getColor(context, R.color.purple_500)
//
//        // Установка цвета иконок в статус-баре
//        val controller = activity?.window?.let { activity.window?.decorView?.let { it1 ->
//            WindowCompat.getInsetsController(it,
//                it1
//            )
//        } }
//
//        controller?.isAppearanceLightStatusBars = true // Установите в true для светлых иконок
//// Установите флаги SYSTEM_UI_FLAG_LIGHT_STATUS_BAR и SYSTEM_UI_FLAG_LAYOUT_STABLE для светлых иконок и текста


        Log.d("dip17", "selectedIndex: ${selectedIndex.value}")
        Log.d("dip17", "iconColor: $iconColor")


        // Log.d("dip17", "screenWidth: $screenWidth")

        Column(
            Modifier
                .padding(0.dp)
        ) {
            Divider(color = Color.Gray, thickness = 1.dp)

            Row(
                Modifier
                    .fillMaxWidth()
                    .background(Color.Gray), horizontalArrangement = Arrangement.spacedBy(1.dp)
            ) {
                TextField(
                    value = station.value.take(24),
                    onValueChange = { },
                    label = {
                        Text("Station:  ${connectionState.value}")

//                        if (connectionState.value != "OK") {
//                            Text("Station:  Connection ...")
//                        } else {
//                            Text("Station: ")
//                        }
                    },

                    enabled = false,
                    modifier = Modifier
                        .fillMaxWidth()
                        .weight(0.62f, false)
                    //.wrapContentWidth()
                    //.padding(0.dp, 0.dp, 0.dp, 0.dp),
                    ,
                    maxLines = 1,
                    readOnly = true,
                    textStyle = TextStyle(
                        fontSize = 16.sp,
                        color = MaterialTheme.colorScheme.primary,
                        fontWeight = FontWeight.Bold,
                    ),
                    shape = RoundedCornerShape(0.dp) // Устанавливаем углы без закруглений
                )

                TextField(
                    value = "Vol: ${volume.value}",
                    onValueChange = { },
                    label = {
                        Text(
                            text = state.value,
                            style = TextStyle(
                                color = MaterialTheme.colorScheme.primary, //
                                fontSize = 12.sp, // изменяем размер текста label на 18sp
                                fontWeight = if (state.value != "Power OFF") FontWeight.Bold else FontWeight.Normal, // изменяем стиль текста в зависимости от значения state
                            ),
                            modifier = Modifier.padding(start = 0.dp) // задаем отступ текста от левого края в 8dp
                        )
                    },


                    trailingIcon = {
                        IconButton(onClick = { expanded = true }) {
                            Icon(
                                imageVector = Icons.Filled.Notifications /* Ваш векторный ресурс */,
                                contentDescription = "Меню",
                                tint = iconColor // Устанавливаем цвет иконки
                            )
                        }
                    },

                    enabled = false,
                    modifier = Modifier
                        .fillMaxWidth()
                        .weight(0.38f, true),
                    //.wrapContentWidth(),
                    maxLines = 1,
                    readOnly = true,
                    textStyle = TextStyle(
                        fontSize = 16.sp,
                        color = MaterialTheme.colorScheme.primary,
                        //textAlign = TextAlign.End,
                        fontWeight = FontWeight.Bold
                    ),
                    shape = RoundedCornerShape(0.dp) // Устанавливаем углы без закруглений
                )

                DropdownMenu(
                    expanded = expanded,
                    onDismissRequest = { expanded = false }, // обработчик нажатия вне экрана
                    offset = DpOffset(x = screenWidth.dp - 100.dp, y = 0.dp),
                ) {
                    alarms.dropLast(1).forEachIndexed { index, item ->
                        DropdownMenuItem(
                            onClick = {
                                selectedIndex.value = index
                                expanded = false
                                Log.d("dip17", "selectedIndex: $selectedIndex")
                            },
                            text = {
                                Row(verticalAlignment = Alignment.CenterVertically) {
                                    Text(item)
                                    if (index == selectedIndex.value) {
                                        Spacer(modifier = Modifier.width(8.dp)) // Промежуток между текстом и иконкой
                                        Icon(
                                            Icons.Filled.Check,
                                            contentDescription = null
                                        ) // Иконка галочки
                                    }

                                }
                            },
                            modifier = Modifier.background(
                                if (index == selectedIndex.value) MaterialTheme.colorScheme.primary.copy(
                                    alpha = 0.12f
                                )
                                else Color.Transparent
                            )
                        )
                    }
                    Divider(color = Color.Gray, thickness = 1.dp)
                    DropdownMenuItem(
                        onClick = {
                            selectedIndex.value = alarms.lastIndex
                            expanded = false
                            Log.d("dip17", "selectedIndex: ${selectedIndex.value}")
                        },
                        text = {
                            Row(verticalAlignment = Alignment.CenterVertically) {
                                Text(alarms[alarms.lastIndex])
                                if (selectedIndex.value == alarms.lastIndex) {
                                    Spacer(modifier = Modifier.width(8.dp)) // Промежуток между текстом и иконкой
                                    Icon(
                                        Icons.Filled.Check,
                                        contentDescription = null
                                    ) // Иконка галочки
                                }

                            }
                        },
                        modifier = Modifier.background(
                            if (selectedIndex.value == alarms.lastIndex) MaterialTheme.colorScheme.primary.copy(
                                alpha = 0.12f
                            )
                            else Color.Transparent
                        )
                    )
                }
            }
            //TextFieldComponent("Title:", title.value)
            TextField(
                value = title.value,
                onValueChange = { },
                label = { Text(text = "Title:                ${logText.value}") },
                //label = { Text( text = "Title: ")},
                enabled = false,
                modifier = Modifier
                    .fillMaxWidth(),

                maxLines = 3,
                readOnly = true,
                textStyle = TextStyle(
                    fontSize = 16.sp,
                    color = MaterialTheme.colorScheme.primary,
                    fontWeight = FontWeight.Bold
                )
            )

            Column(Modifier.padding(vertical = 4.dp, horizontal = 8.dp)) {
                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                    ButtonComponent(
                        "POWER",
                        "b1",
                        Modifier.weight(1f),
                        context,
                        Icons.Default.CheckCircle,
                        false
                    ) {}
                    ButtonComponent(
                        "CH +",
                        "b3",
                        Modifier.weight(1f),
                        context,
                        Icons.Default.Add,
                        false
                    ) {}
                    ButtonComponent(
                        "VOL +",
                        "vol+",
                        Modifier.weight(1f),
                        context,
                        Icons.Default.KeyboardArrowUp,
                        false
                    ) {}
                }
                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                    ButtonComponent(
                        "SLEEP",
                        "b2",
                        Modifier.weight(1f),
                        context,
                        Icons.Default.Done,
                        false
                    ) {}
                    ButtonComponent(
                        "CH -",
                        "b4",
                        Modifier.weight(1f),
                        context,
                        Icons.Default.ArrowDropDown,
                        false
                    ) {}
                    ButtonComponent(
                        "VOL -",
                        "vol-",
                        Modifier.weight(1f),
                        context,
                        Icons.Default.KeyboardArrowDown,
                        false
                    ) {}
                }
            }

            Divider(color = Color.Gray, thickness = 1.dp)

            LazyVerticalGrid(
                columns = GridCells.Fixed(cellsCount), // Фиксированное количество ячеек в строке
                contentPadding = PaddingValues(8.dp), // Отступы вокруг сетки
                horizontalArrangement = Arrangement.spacedBy(8.dp), // Горизонтальное расстояние между элементами
                verticalArrangement = Arrangement.spacedBy(2.dp) // Вертикальное расстояние между элементами
            ) {
                items(buttonDataList.size) { index ->
                    MQTTButton(buttonDataList[index], index)
                }
            }
        }

        fun convertTimeToSeconds(time: String): Int {
            val parts = time.split(":")
            val hours = parts[0].toInt()
            val minutes = parts[1].toInt()
            return hours * 3600 + minutes * 60
        }

        LaunchedEffect(selectedIndex.value) // срабатывает при изменении selectedIndex
        {
            Log.i("dip17", "LaunchedEffect selectedIndex: ${selectedIndex.value}")
            if (selectedIndex.value != null) {
                coroutineScope.launch(Dispatchers.IO) { // Запуск в фоновом потоке
                    try {
                        if (alarms[selectedIndex.value!!] != "Alarm OFF") {
                            val sec = convertTimeToSeconds(alarms[selectedIndex.value!!])

                            val message = MqttMessage("s$sec".toByteArray())
                            client.publish("Home/$radioName/Action", message)
                        } else {
                            val message = MqttMessage("sAlarm OFF".toByteArray())
                            client.publish("Home/$radioName/Action", message)
                        }

                    } catch (e: MqttException) {
                        // Обработка ошибки подключения или публикации
                        Log.e("MQTTError", "Ошибка связи с брокером: ${e.message}")
                    }
                }
            }
        }


    }
//@OptIn(ExperimentalLayoutApi::class)
//@Composable
//fun MQTTButtonsScreen(buttonDataList: List<ButtonData>, mqttClient: MqttClient) {
//    FlowRow(
//        modifier = Modifier,
//        verticalArrangement = Arrangement.spacedBy(10.dp),
//        horizontalArrangement = Arrangement.spacedBy(10.dp),
//        content = {buttonDataList.forEach { buttonData ->
//            MQTTButton(buttonData, mqttClient) }}
//    )
//}

    @Composable
    fun MQTTButton(
        buttonData: ButtonData,
        index: Int,
    ) {
        val context = LocalContext.current
        val coroutineScope = rememberCoroutineScope()
        val isPressed = remember { mutableStateOf(false) } // Состояние для отслеживания нажатия
        //
        val buttonColors = when (buttonData.genre) { // todo перенести цвета в тему
            "rock" -> ButtonDefaults.buttonColors(containerColor = Color(200, 50, 20))
            "jazz" -> ButtonDefaults.buttonColors(containerColor = Color(0, 100, 50))
            "radio" -> ButtonDefaults.buttonColors(containerColor = Color(0, 100, 200))
            "relax" -> ButtonDefaults.buttonColors(containerColor = Color(20, 100, 100))
            "ambient" -> ButtonDefaults.buttonColors(containerColor = Color(20, 20, 100))
            "lounge" -> ButtonDefaults.buttonColors(containerColor = Color(100, 0, 100))
            "electronic" -> ButtonDefaults.buttonColors(containerColor = Color(156, 39, 176, 255))
            "country" -> ButtonDefaults.buttonColors(containerColor = Color.LightGray)
            "reggae" -> ButtonDefaults.buttonColors(containerColor = Color.Gray)
            "nature" -> ButtonDefaults.buttonColors(containerColor = Color(0, 200, 150))
            else -> ButtonDefaults.buttonColors(
                containerColor = Color(
                    150,
                    150,
                    140
                )
            ) // Цвет по умолчанию
        }

        Button(
            onClick = {
                isPressed.value = true // Устанавливаем состояние нажатия
                CoroutineScope(Dispatchers.IO).launch {
                    val mediaPlayer = MediaPlayer.create(context, R.raw.button1)
                    // Установка громкости на 50% для обоих каналов
                    mediaPlayer.setVolume(0.5f, 0.5f)
                    mediaPlayer.start()
                }
                coroutineScope.launch(Dispatchers.IO) { // Запуск в фоновом потоке
                    try {
                        //Log.d("dip17", "MQTTButton click start")
                        if (state.value == "Power OFF") {
                            val message = MqttMessage("b1".toByteArray())
                            client.publish("Home/$radioName/Action", message)
                        }
                        station.value = " - - - "
                        title.value = " - - - "
                        logText.value = ""

                        val message = MqttMessage(buttonData.messageText.toByteArray())
                        client.publish("Home/$radioName/Action", message)

                        //Log.d("dip17", "MQTTButton click finish")
                    } catch (e: MqttException) {
                        // Обработка ошибки подключения или публикации
                        Log.e("MQTTError", "Ошибка связи с брокером: ${e.message}")
                        // Здесь можно добавить код для отображения уведомления пользователю
                    }
                }
            },
            modifier = Modifier
                //.longClickGestureFilter(onLongClick = { /* обработчик длительного нажатия */ })
                .fillMaxWidth(),
            //.background(if(isPressed.value)Color.Green.copy(alpha = 0.5f) else Color.Transparent),
            shape = RoundedCornerShape(8.dp),
            colors = buttonColors, // Использование определенного выше цвета кнопки
            contentPadding = PaddingValues(8.dp) // Установка внутренних отступов кнопки
        ) {
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(0.dp),
                //        .background(if(isPressed.value)Color.Green.copy(alpha = 0.5f) else Color.Transparent),
                contentAlignment = Alignment.CenterStart
            ) {
                Text(
                    text = "${index + 1} ${buttonData.buttonText}",
                    style = TextStyle(
                        color = Color.White,
                        fontSize = 16.sp,
                        fontWeight = FontWeight.Bold // Установка жирного шрифта
                    )
                )
            }
        }
    }

    @Composable
    fun ButtonComponent(
        buttonText: String,
        message: String,
        modifier: Modifier,
        context: Context,
        icon: ImageVector,
        isIconVisible: Boolean = true,
        toggleIconVisibility: () -> Unit = {}
    ) {
        Button(
            onClick = {
                CoroutineScope(Dispatchers.IO).launch {
                    val mediaPlayer = MediaPlayer.create(context, R.raw.button1)
                    mediaPlayer.setVolume(0.5f, 0.5f)
                    mediaPlayer.start()
                }
                Log.d("dip17", "PRESS KEY!")
                if ((message == "b1") || (message == "b3") || (message == "b4")) {
                    //Log.d("dip17", "PRESS!")
                    station.value = " - - -"
                    title.value = " - - - "
                    logText.value = ""
                }

                Log.d("dip17", "Send message: $message")
                //sendMessage(message)
                val msg = MqttMessage(message.toByteArray())
                client.publish("Home/$radioName/Action", msg)

                toggleIconVisibility()
            }, modifier
        ) {
            Text(
                text = buttonText,
                style = TextStyle(
                    //color = Color.White,
                    fontSize = 16.sp,
                    fontWeight = FontWeight.Bold
                )
            )
            if (isIconVisible) {
                Icon(
                    imageVector = icon,
                    contentDescription = null,
                    tint = Color.Green
                )
            }
        }
    }

    @Composable
    fun TextFieldComponent(topic: String, text: String = "") {

        TextField(
            value = text,
            onValueChange = { },
            label = { Text(topic) },
            enabled = false,
            modifier = Modifier
                .fillMaxWidth(),

            maxLines = 3,
            readOnly = true,
            textStyle = TextStyle(
                fontSize = 16.sp,
                color = MaterialTheme.colorScheme.primary,
                fontWeight = FontWeight.Bold
            )
        )
    }
}
